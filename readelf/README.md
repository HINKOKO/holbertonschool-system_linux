# **C - ELF: readelf**

## **Learning Objectives**

- **What is the ELF format**

	**ELF** is **NOT** a ***A type of supernatural being in Germanic mythology and folklore*** , it rather stands for <br>
	**E**xecutable and **L**inkable **F**ormat. <br>
	***An ELF defines how instructions are stored in executable code.***
	In C programming, generated by the Compiler and the Linker. <br>
	The Compiler --> produces an object files (containing compiled code and data) <br>
	The Linker --> combines that object files with other object files and libraries to produce an executable.
	By design, the ELF Format is cross-platform, flexible, extensible (support differents Endianesses for instance).

	***Why bother learn ELF ?***
	That learning helps to understand the inner working of our OS. In the case of security breach or suspicious files
	being able to look for and understand ELF is really valuable. We can gather the benefits like so:
	- Generic in-depth understanding of how the OS works
	- Development of software
	- **DFIR** Digital Forensics and Incident Response
	- Malware research (binary analysis) 

- **What kind of files are in the ELF format**

	Here are some files in the ELF format:
	- **Executable files**, programs that can be run directly by the OS.
	- **Object files**, That is to say compiled code that has not yet been linked into an executable. (extension **.o**)
	- **Shared libraries**, code modules that can be used by mutiple programs at the same time. (extension **.so**)
	- **Core dump files**, when a program crash, the core dump is a "snapshot" of the program's memory at the moment of the crash.
	- **Kernel modules** (in some Unix-like OS).

- **What are the different parts that constitute an ELF file**
	Generally speaking, ELF files are composed of three main parts:
	- ELF Header
	- Program headers or **Segments**
	- Section headers or **Sections**
	
	As its name suggest, **E**xecutable and **L**inkable format suggests 2 views,
	which involves a general layout of a typical ELF file as follow:
	```
	**Linking View**				**Execution View**

	+----------------+               +----------------+ 
	|   ELF Header   |               |   ELF Header   |
	+----------------+               +----------------+ 
	| Program header |               | Program header |
	|     table      |               |     table      | 
	|   (optional)   |               |                |
	+----------------+               +----------------+
	|   Section 1    |               |    Segment 1   |
	+----------------+               |                |
	|      ...       |               |                |
	+----------------+               +----------------+
	|      ...       |               |    Segment 2   |
	+----------------+               |                |
	|   Section n    |               +----------------+
	+----------------+               |                |
	|      ...       |               |      ...       |
	+----------------+               +----------------+
	| Section header |               | Section header |
	|      table     |               | table(optional)|
	+----------------+               +----------------+
	```


- **What information are present in the file header**
	```
	ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400500
  Start of program headers:          64 (bytes into file)
  Start of section headers:          6808 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 28

	```
	Among the different fields we can find, here are some of interests:
	- **Magic** => ELF starts with **`Magic`** field,  What an intro ! This kind of "Magic" (who's Queen was singing about in 1986) provides information about the file. The first 4 hexadecimals numbers are known as **"the magic number"**, if we look at them carefully we got this: <br>
	45 = E
	4c = F
	46 = F
	Enigma cracked ! we got "ELF" written in the ELF File header magic field.
	Good, and what about the " 7f " ? it represents the file formant and the architecture of the ELF Binary file, **" 7f "** is known as the **"ELF identification byte "** or **"EI_MAGO "**, its purpose is a file identification marker and is always set to the value **" 0x7f "** for ELF Files.
	- **Class** => This value is for specifying the architecture of the file,
	either **32-bit (=01)** or **64-bit (=02)** architecture.
	- **Data** => Data field will get either 01 for **LSB** (Least Significant Bit, little-endian) or 02 for **MSB** (Most Significant Bit, big-endian).
	This value is helpful to correctly interpret the remaining parts within the ELF file.

- **What information are present in the sections header table**
	This "view" of the ELF file is used for linking and relocation, a catchy explanation taken from ***Computer Science from the Bottom Up*** <br>
	declares this : <br>
	***Sections are a way to organize binary into logical areas to communicate information between the compiler and the linker*** <br>
	
	For the executable files, which we are working with in this project, we find 4 main sections:
	- `.text` contains executable code, loaded only once and packed into a segment (as it won't change)
	- `.data` initialized data with read and write access rights
	- `.rodata` initialized data with read only access rights
	- `.bss` Uninitialiazed data, read and write access rights
	 
	 ## about **SHT** **S**ection **H**eader **T**able

	 It **describes** the ***linking view*** of the binary.
	 This table has ***entries*** for all the sections in the binary where each entry describes the respective section attributes. <br>
	 (i.e. the section offset, type, size, flags, etc..)
	 ```
	 There are 31 section headers, starting at offset 0x3780:

	Section Headers:
	[Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
	[ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
	[ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1
	[ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8
	[ 3] .note.gnu.build-id NOTE            0000000000000368 000368 000024 00   A  0   0  4
	[ 4] .note.ABI-tag     NOTE            000000000000038c 00038c 000020 00   A  0   0  4
	[ 5] .gnu.hash         GNU_HASH        00000000000003b0 0003b0 000024 00   A  6   0  8
	[ 6] .dynsym           DYNSYM          00000000000003d8 0003d8 000120 18   A  7   1  8
	[ 7] .dynstr           STRTAB          00000000000004f8 0004f8 0000c4 00   A  0   0  1
	[ 8] .gnu.version      VERSYM          00000000000005bc 0005bc 000018 02   A  6   0  2
	[ 9] .gnu.version_r    VERNEED         00000000000005d8 0005d8 000040 00   A  7   1  8
	[10] .rela.dyn         RELA            0000000000000618 000618 0000c0 18   A  6   0  8
	[11] .rela.plt         RELA            00000000000006d8 0006d8 000090 18  AI  6  24  8
	[12] .init             PROGBITS        0000000000001000 001000 00001b 00  AX  0   0  4
	[13] .plt              PROGBITS        0000000000001020 001020 000070 10  AX  0   0 16
	[14] .plt.got          PROGBITS        0000000000001090 001090 000010 10  AX  0   0 16
	[15] .plt.sec          PROGBITS        00000000000010a0 0010a0 000060 10  AX  0   0 16
	[16] .text             PROGBITS        0000000000001100 001100 0001bf 00  AX  0   0 16
	[17] .fini             PROGBITS        00000000000012c0 0012c0 00000d 00  AX  0   0  4
	[18] .rodata           PROGBITS        0000000000002000 002000 000012 00   A  0   0  4
	[19] .eh_frame_hdr     PROGBITS        0000000000002014 002014 000034 00   A  0   0  4
	[20] .eh_frame         PROGBITS        0000000000002048 002048 0000ac 00   A  0   0  8
	[21] .init_array       INIT_ARRAY      0000000000003d90 002d90 000008 08  WA  0   0  8
	[22] .fini_array       FINI_ARRAY      0000000000003d98 002d98 000008 08  WA  0   0  8
	[23] .dynamic          DYNAMIC         0000000000003da0 002da0 0001f0 10  WA  7   0  8
	[24] .got              PROGBITS        0000000000003f90 002f90 000070 08  WA  0   0  8
	[25] .data             PROGBITS        0000000000004000 003000 000010 00  WA  0   0  8
	[26] .bss              NOBITS          0000000000004010 003010 000008 00  WA  0   0  1
	[27] .comment          PROGBITS        0000000000000000 003010 00002b 01  MS  0   0  1
	[28] .symtab           SYMTAB          0000000000000000 003040 0003d8 18     29  18  8
	[29] .strtab           STRTAB          0000000000000000 003418 000247 00      0   0  1
	[30] .shstrtab         STRTAB          0000000000000000 00365f 00011a 00      0   0  1
	Key to Flags:
	W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
	L (link order), O (extra OS processing required), G (group), T (TLS),
	C (compressed), x (unknown), o (OS specific), E (exclude),
	D (mbind), l (large), p (processor specific)

	 ```

- **What information are present in the program header table**
	A program header table - also known as ***program segment header table*** 
	descrisbes ***segments** within a binary and are necessary for program loading.
	These segments are understood by the kernel during load time and describe the memory layout of an executable on disk,
	and how it should translate to memory.
	==> That program table provides essential infos for the kernel to **load and execute** the binary.

- **How to parse an ELF file using C structures**
	The ``/usr/include/elf.h`` header file is a standard C header file which defines data structures, constants and macros used to parse and manipulate ELF files.
